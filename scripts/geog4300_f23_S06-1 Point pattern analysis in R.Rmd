---
title: "Point pattern analysis in R"
output: html_notebook:
editor_options: 
  chunk_output_type: console
---
##Nearest neighbors

The spatialEco package has a "nni" function that allows you to easily calculate the Nearest Neighbor Index, a measure of spatial clustering. To use it, you'll have to transform these data into a different spatial format--the as_Spatial format does this part. The NNI and z-score tell you the index and a measure of significance--generally any absolute value higher than 1.96 would be significant.

```{r}
#install.packages("spatialEco")
library(spatialEco)
nni(as_Spatial(dollars))
```

####You try it!
Create new data frames from the dollar store dataset for Family Dollar and Dollar General. Compute the NNI index for each. What does each result tell you?

```{r}

```


##Point pattern analysis with census tracts
We can use st_join to do a *spatial join* between stores and the underlying PUMAs. See [this page](https://gisgeography.com/spatial-join/) for an explanation of spatial joins. The st_join function will join all the variables for the PUMA each store is in based on its location--in this case whether the store is *within* the PUMA polygon (st_within). The tract data is not in WGS 84, so we will set the projection while joining.

```{r}
dollars_puma<-dollars %>%
  st_join(atl_pumas %>% st_transform(4326), #st_transform changes the projection to the listed EPSG number
          join=st_within) %>%
  filter(is.na(GEOID)==FALSE)

#Plot stores by tract
ggplot(dollars_puma) + 
  geom_sf(aes(color=GEOID),show.legend=FALSE)
```

We can then remove the geometry column (which contains the spatial data) using the st_set_geometry function. This will transform the stores back to a regular data frame. 

```{r}
dollars_puma_df<-dollars_puma %>%
  st_set_geometry(NULL) 
```

What if we wanted to see how many stores there are in each PUMA? We can then tally these points using the GEOID field (tract fips code) and the store category variable using the count function, which basically combines group_by and summarise.

```{r}
dollars_puma_count<-dollars_puma_df %>%
  count(GEOID,dollar_type)
```

These data are in long format. We can use pivot_wider and mutate to make this easier to read and calculate the total number of stores and the percentage of stores for each chain. 

```{r}
dollars_puma_count_wide<-dollars_puma_count %>%
  pivot_wider(names_from=dollar_type,
              values_from=n,
              values_fill=0) %>%
  mutate(total_stores=`Dollar General`+`Family Dollar`+`Dollar Tree`,
         dg_pct=`Dollar General`/total_stores*100,
         fd_pct=`Family Dollar`/total_stores*100,
         dt_pct=`Dollar Tree`/total_stores*100)
```

Now we can join those summary data to the PUMA boundary dataset. 

```{r}
atl_pumas_join<-atl_pumas %>%
  left_join(dollars_puma_count_wide)
```

Note that in order to preserve the geometry column, you always want to join non-spatial data TO spatial data. That is, it should always looks like this: spatial data %>% left_join(non-spatial data).

###Quadrats in R
Quadrat analysis is also possible in R. To create quadrats, you can use `st_make_grid` from the sf package. You can change the size and shape (hex/square).

```{r}
grid1<-st_make_grid(atl_pumas,cellsize=0.05)
grid2<-st_make_grid(atl_pumas,cellsize=0.1)
grid3<-st_make_grid(atl_pumas,cellsize=0.05,square=FALSE)

ggplot()+
  geom_sf(data=grid1)+
  geom_sf(data=atl_pumas,alpha=0.5)

ggplot()+
  geom_sf(data=grid2)+
  geom_sf(data=atl_pumas,alpha=0.5)

ggplot()+
  geom_sf(data=grid3)+
  geom_sf(data=atl_pumas,alpha=0.5)

```

To add a row number ID, just use the `row_number` function. This can be useful for spatial joins.

```{r}
grid1<-st_make_grid(atl_pumas,cellsize=0.05) %>%
  mutate(rowID=row_number())
```


###Calculating location quotient
What if we wanted the location quotient for the percentage of Dollar General stores in each PUMA to be able to more easily compare them? We already have most of the data we need to calculate this figure. First, we need to calculate a rate for the whole metro area. We can use the nrow function to count restaurants and then create an object with the percentage that are sandwich restaurants.

```{r}
total_rest=nrow(dollars_puma)
dg_rest=nrow(dollars_puma %>% filter(dollar_type=="Dollar General"))
area_ratio=dg_rest/total_rest*100
```

Getting the LQ is simple using mutate.

```{r}
atl_pumas_join<-atl_pumas_join %>%
  mutate(dg_lq=dg_pct/area_ratio)
```

#You try it!
Calculate the LQ for another chain of your choosing.

```{r}

```


