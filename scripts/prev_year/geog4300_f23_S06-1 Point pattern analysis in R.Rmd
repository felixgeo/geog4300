---
title: "Point pattern analysis in R"
output: html_notebook:
editor_options: 
  chunk_output_type: console
---

```{r setup}
library(tidyverse)
library(sf)
library(tmap)

dollars<-read_csv("data/dollars.csv") %>%
  st_as_sf(coords=c("x","y"),crs=4326)

atl_pumas<-st_read("data/atl_pumas.gpkg")

```


##Nearest neighbors

The spatialEco package has a "nni" function that allows you to easily calculate the Nearest Neighbor Index, a measure of spatial clustering. To use it, you'll have to transform these data into a different spatial format--the as_Spatial format does this part. The NNI and z-score tell you the index and a measure of significance--generally any absolute value higher than 1.96 would be significant.

```{r}
#install.packages("spatialEco")
library(spatialEco)
nni(as_Spatial(dollars))
```

####You try it!
Create new data frames from the dollar store dataset for Family Dollar and Dollar General. Compute the NNI index for each. What does each result tell you?

```{r}

```


##Point pattern analysis with census tracts
We can use st_join to do a *spatial join* between stores and the underlying PUMAs. See [this page](https://gisgeography.com/spatial-join/) for an explanation of spatial joins. The st_join function will join all the variables for the PUMA each store is in based on its location--in this case whether the store is *within* the PUMA polygon (st_within). The tract data is not in WGS 84, so we will set the projection while joining.

```{r}
dollars_puma<-dollars %>%
  st_join(atl_pumas %>% st_transform(4326), #st_transform changes the projection to the listed EPSG number
          join=st_within) %>%
  filter(is.na(GEOID)==FALSE)

#Plot stores by tract
tm_shape(dollars_puma) + 
  tm_dots("GEOID",size=0.2)+
  tm_legend(legend.show=FALSE)
```

We can then remove the geometry column (which contains the spatial data) using the st_set_geometry function. This will transform the stores back to a regular data frame. 

```{r}
dollars_puma_df<-dollars_puma %>%
  st_set_geometry(NULL) 
```

What if we wanted to see how many stores there are in each PUMA? We can then tally these points using the GEOID field (tract fips code) and the store category variable using the count function, which basically combines group_by and summarise.

```{r}
dollars_puma_count<-dollars_puma_df %>%
  count(GEOID,dollar_type)
```

These data are in long format. We can use pivot_wider and mutate to make this easier to read and calculate the total number of stores and the percentage of stores that are Family Dollars in each PUMA. 

```{r}
dollars_puma_count_wide<-dollars_puma_count %>%
  pivot_wider(names_from=dollar_type,
              values_from=n,
              values_fill=0) %>%
  mutate(total_stores=`Dollar General`+`Family Dollar`+`Dollar Tree`,
         fd_pct=`Family Dollar`/total_stores*100)
```

Now we can join those summary data to the PUMA boundary dataset and map it. 

```{r}
atl_pumas_join<-atl_pumas %>%
  left_join(dollars_puma_count_wide)

tm_shape(atl_pumas_join)+
  tm_polygons("fd_pct")
```

Note that in order to preserve the geometry column, you always want to join non-spatial data TO spatial data. That is, it should always looks like this: spatial data %>% left_join(non-spatial data).

###You try it!
Calculate the percentage of stores that are Dollar Generals and Dollar Trees in each PUMA by adapting the above code. For an extra challenge, use `tmap_arrange` to put all three maps in a single figure. 

See this example of `tmap_arrange`: https://thinking-spatial.org/courses/angewandte_geodatenverarbeitung/kurs04/#by-using-the-tmap_arrange-function

```{r}

```


###Quadrats in R
Quadrat analysis is also possible in R. To create quadrats, you can use `st_make_grid` from the sf package. You can change the size and shape (hex/square).

```{r}
grid1<-st_make_grid(atl_pumas,cellsize=0.05)
grid2<-st_make_grid(atl_pumas,cellsize=0.1)
grid3<-st_make_grid(atl_pumas,cellsize=0.05,square=FALSE)

tm_shape(grid1)+
  tm_borders(col="red",alpha=0.3)+
tm_shape(atl_pumas)+
  tm_borders()
  
tm_shape(grid2)+
  tm_borders(col="red",alpha=0.3)+
tm_shape(atl_pumas)+
  tm_borders()

tm_shape(grid3)+
  tm_borders(col="red",alpha=0.3)+
tm_shape(atl_pumas)+
  tm_borders()

```

To add a row number ID, just use the `row_number` function. This can be useful for spatial joins, as you can join the cell identifier (`rowID`in this case) to each store first, and then count the number of stores by this ID field.

```{r}
grid1<-st_make_grid(atl_pumas,cellsize=0.05) %>%
  mutate(rowID=row_number())
```

###Calculating location quotient
What if we wanted the location quotient for the percentage of Dollar General stores in each PUMA to be able to more easily compare them? We already have most of the data we need to calculate this figure. First, we need to calculate a rate for the whole metro area. We can use the nrow function to count restaurants and then create an object with the percentage that are sandwich restaurants.

```{r}
total_rest=nrow(dollars_puma)
dg_rest=nrow(dollars_puma %>% filter(dollar_type=="Dollar General"))
area_ratio=dg_rest/total_rest*100
```

Getting the LQ is simple using mutate.

```{r}
atl_pumas_join<-atl_pumas_join %>%
  mutate(dg_lq=dg_pct/area_ratio)
```

#You try it!
Calculate the LQ for another chain of your choosing.

```{r}

```


